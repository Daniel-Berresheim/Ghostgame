[gd_scene load_steps=4 format=2]

[ext_resource path="res://objects/basic/Possessable.tscn" type="PackedScene" id=1]

[sub_resource type="GDScript" id=1]

script/source = "extends KinematicBody2D

# Deadzone of controller axis.
const DEADZONE = 0.25

export var gravity = Vector2(0, 1600)

# Movement speed in pixels per second.
export(float) var movement_speed = 1100

# Friction of the movement.
# The player's speed will be multiplied by this value in the span of one second.
export(float) var friction = 0.00002

# The current speed of the moveable.
var speed = Vector2()

# Movement that actually occured since the last _physics_process.
var actual_movement = Vector2()

# True if colliding with ground.
var on_ground = true

onready var _p = $\"Possessable\"

# size of the movable as a rectangle
var size = Vector2(0,0)

# Snapes the position.
func snap_falling_position():
	var gpos = global_position
	gpos.x += sign(speed.x) * 0.01
	global_position = gpos
	speed.x = 0

func _ready():
	add_user_signal(\"impact\", [\"amount\"])
	
	# get the size of the object
	var points = $\"CollisionShape2D\".get_shape().get_points()
			
	var min_pos = Vector2(points[0].x, points[0].y)
	var max_pos = Vector2(points[0].x, points[0].y)
			
	for i in points.size():
				
		if points[i].x < min_pos.x: min_pos.x = points[i].x
		if points[i].y < min_pos.y: min_pos.y = points[i].y
				
		if points[i].x > max_pos.x: max_pos.x = points[i].x
		if points[i].y > max_pos.y: max_pos.y = points[i].y
			
	size = Vector2(max_pos.x - min_pos.x, max_pos.y - min_pos.y)

func _physics_process(delta):
	
	var on_ground_new = test_move(global_transform, Vector2(0, 1))
	
	if on_ground_new:
		
		# todo: 
		# - moving other Movables by pushing them
		# - moving other Movables if they are on top of another moving Movable
		# - moving this code block to another position to save performance
		
		if Input.is_action_just_pressed(\"info\"):
			
			var movables = get_tree().get_nodes_in_group(\"Movables\")
			movables.erase(self)
			
			var t_position = global_position
			var t_size = size
			
			var tlu = Vector2(t_position.x - t_size.x/2, t_position.y - t_size.y/2 -1)
			var trd = Vector2(t_position.x + t_size.x/2, t_position.y - t_size.y/2)
			
			for i in movables.size():
				var overlap = true
				
				var e_position = movables[i].global_position
				var e_size = movables[i].size
				
				var elu = Vector2(e_position.x - e_size.x/2, e_position.y - e_size.y/2)
				var erd = Vector2(e_position.x + e_size.x/2, e_position.y + e_size.y/2)
				
				# check for collision
				if tlu.x > erd.x or elu.x > trd.y: overlap = false
				if tlu.y > erd.y or elu.y > trd.y: overlap = false
			
				if overlap: print(movables[i].name)
			
			pass
		
		# if the object was falling and hits the ground, it stops playing a falling sound and an impact sound occures
		if not on_ground:
			
			var snd_falling = $\"Sounds/Falling\"
			snd_falling.stop()
			
			emit_signal(\"impact\", speed.x)
			var snd_impact = $\"Sounds/Impact\"
			snd_impact.volume_db = clamp(-60 + actual_movement.length() * 8, -60, -2)
			snd_impact.play()
		
		# if the object is possessable, the horizontal moving direction will be determined
		if _p.possessed:
			var analog = _deadzone(Vector2(Input.get_joy_axis(0, JOY_AXIS_0), 0))
			if analog != Vector2():
				speed += analog * movement_speed * delta
			else:
				var dir = Vector2()
				dir.x += int(Input.is_action_pressed(\"move_right\")) - int(Input.is_action_pressed(\"move_left\"))
				speed += dir.normalized() * movement_speed * delta
	else:
		
		if _p.possessed and on_ground: snap_falling_position()
		
		var snd_falling = $\"Sounds/Falling\"
		if not snd_falling.is_playing():
			snd_falling.play()
		
		snd_falling.volume_db = clamp(-60 + actual_movement.length(), -60, -24)
		speed += gravity * delta
	
	on_ground = on_ground_new
	
	speed.x *= pow(friction, delta)
	
	actual_movement = global_position
	speed = move_and_slide(speed, Vector2(0, -1))
	actual_movement = (actual_movement - global_position) / delta
	
	# moves the player along with the object it possesses
	if _p.possessed: _p.player.global_position = global_position

func _deadzone(axis):
	var length = axis.length()
	
	if length < DEADZONE:
		return Vector2()
	if length > 1:
		return axis.normalized()
	
	return axis"

[sub_resource type="CircleShape2D" id=2]

custom_solver_bias = 0.0
radius = 24.0

[node name="Moveable" type="KinematicBody2D" index="0" groups=[
"Movables",
]]

input_pickable = false
collision_layer = 8
collision_mask = 11
collision/safe_margin = 0.08
script = SubResource( 1 )
_sections_unfolded = [ "Collision" ]
gravity = Vector2( 0, 1600 )
movement_speed = 1100
friction = 2e-005

[node name="Possessable" parent="." index="0" instance=ExtResource( 1 )]

[node name="PossessArea" type="CollisionShape2D" parent="Possessable" index="1"]

shape = SubResource( 2 )


